# 1.[所有部门中当前员工的当前薪水最高的相关信息](https://www.nowcoder.com/practice/4a052e3e1df5435880d4353eb18a91c6?tpId=82&tags=&title=&diffculty=0&judgeStatus=0&rp=1&ru=/ta/sql&qru=/ta/sql/question-ranking)

获取所有部门中当前(dept_emp.to_date = '9999-01-01')员工当前(salaries.to_date='9999-01-01')薪水最高的相关信息，给出dept_no, emp_no以及其对应的salary。
CREATE TABLE `dept_emp` (
`emp_no` int(11) NOT NULL,
`dept_no` char(4) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,
PRIMARY KEY (`emp_no`,`dept_no`));
CREATE TABLE `salaries` (
`emp_no` int(11) NOT NULL,
`salary` int(11) NOT NULL,
`from_date` date NOT NULL,
`to_date` date NOT NULL,

PRIMARY KEY (`emp_no`,`from_date`));

# 2. 解法

## 2.1 子查询 + 聚合

分析：题目的要求是要返回每个部门的当前员工里，当前薪资最高的人。也就是说，当前状态下，每个部门的最高薪资员工。

思路：按照部门聚合，然后返回每个部门符合要求员工的最高薪资者。

- 先通过子查询返回符合要求的员工集合。（要求是：当前员工，当期部门，薪资降序）
- 在符合要求的员工集合中，按部门聚合，并返回每个部门薪资最高的人/人们。

```sql
select f.dept_no, f.emp_no, max(f.salary)
from  ( select d.dept_no, s.emp_no, s.salary
        from salaries s, dept_emp d
        where s.emp_no = d.emp_no
              and s.to_date = '9999-01-01'
              and d.to_date = '9999-01-01'
        order by s.salary desc ) as f
group by f.dept_no
```

知识点：

- 使用group by子句时，select子句中只能有聚合键、聚合函数、常数。
- 也就是说，这里的max作用于每个部门分组。有多少个部门就至少返回多少个记录项（因为会有最高薪相同的人）

还可以用join 来改写子查询部分内容：

```sql
select f.dept_no, f.emp_no, max(f.salary)
from  ( select d.dept_no, s.emp_no, s.salary
        from salaries s
        join dept_emp d
        on s.emp_no = d.emp_no
        and s.to_date = '9999-01-01'
        and d.to_date = '9999-01-01'
        order by s.salary desc ) as f
group by f.dept_no
```



## 2.2 聚合的特性

**GROUP BY 默认取非聚合的第一条记录**，将max(f.salary) 去掉max()，  然后下面的代码也通过了。说明题目要返回的是最高薪者，每个部门只有一个。

```sql
select f.dept_no, f.emp_no, f.salary
from  ( select d.dept_no, s.emp_no, s.salary
        from salaries s
        join dept_emp d
        on s.emp_no = d.emp_no
        and s.to_date = '9999-01-01'
        and d.to_date = '9999-01-01'
        order by s.salary desc ) as f
group by f.dept_no
```

